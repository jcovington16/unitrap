import { type Signal, type SignalAndInterval, type ReadConfig, type ChainName } from "../helpers/index.js";
import { type Version } from "./version.js";
import { type Table, type Params as TableParams, type Column, type Schema } from "./tables.js";
import { type Params as QueryParams, type TableFormat, type ObjectsFormat } from "./query.js";
import { type TransactionReceipt, type Params as ReceiptParams } from "./receipt.js";
export { ApiError } from "./client/index.js";
export { type TransactionReceipt, type Table, type TableFormat, type ObjectsFormat, type QueryParams, type Column, type Schema, };
/**
 * Validator provides direct access to remote Validator REST APIs.
 */
export declare class Validator {
    readonly config: ReadConfig;
    /**
     * Create a Validator instance with the specified connection configuration.
     * @param config The connection configuration. This must include a baseUrl
     * string. If passing the config from a pre-existing Database instance, it
     * must have a non-null baseUrl key defined.
     */
    constructor(config?: Partial<ReadConfig>);
    /**
     * Create a new Validator instance that uses the default baseUrl for a given chain.
     * @param chainNameOrId The name or id of the chain to target.
     * @returns A Validator with a default baseUrl.
     */
    static forChain(chainNameOrId: ChainName | number): Validator;
    /**
     * Get health status
     * @description Returns OK if the validator considers itself healthy
     */
    health(opts?: Signal): Promise<boolean>;
    /**
     * Get version information
     * @description Returns version information about the validator daemon
     */
    version(opts?: Signal): Promise<Version>;
    /**
     * Get table information
     * @description Returns information about a single table, including schema information
     */
    getTableById(params: TableParams, opts?: Signal): Promise<Table>;
    /**
     * Query the network
     * @description Returns the results of a SQL read query against the Tabeland network
     */
    queryByStatement<T = unknown>(params: QueryParams<"objects" | undefined>, opts?: Signal): Promise<ObjectsFormat<T>>;
    queryByStatement<T = unknown>(params: QueryParams<"table">, opts?: Signal): Promise<TableFormat<T>>;
    /**
     * Get transaction status
     * @description Returns the status of a given transaction receipt by hash
     */
    receiptByTransactionHash(params: ReceiptParams, opts?: Signal): Promise<TransactionReceipt>;
    /**
     * Wait for transaction status
     * @description Polls for the status of a given transaction receipt by hash until
     */
    pollForReceiptByTransactionHash(params: ReceiptParams, opts?: SignalAndInterval): Promise<TransactionReceipt>;
}
//# sourceMappingURL=index.d.ts.map