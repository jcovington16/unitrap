"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = exports.ApiError = void 0;
const index_js_1 = require("../helpers/index.js");
const health_js_1 = require("./health.js");
const version_js_1 = require("./version.js");
const tables_js_1 = require("./tables.js");
const query_js_1 = require("./query.js");
const receipt_js_1 = require("./receipt.js");
var index_js_2 = require("./client/index.js");
Object.defineProperty(exports, "ApiError", { enumerable: true, get: function () { return index_js_2.ApiError; } });
/**
 * Validator provides direct access to remote Validator REST APIs.
 */
class Validator {
    /**
     * Create a Validator instance with the specified connection configuration.
     * @param config The connection configuration. This must include a baseUrl
     * string. If passing the config from a pre-existing Database instance, it
     * must have a non-null baseUrl key defined.
     */
    constructor(config = {}) {
        /* c8 ignore next 3 */
        if (config.baseUrl == null) {
            throw new Error("missing baseUrl information");
        }
        this.config = config;
    }
    /**
     * Create a new Validator instance that uses the default baseUrl for a given chain.
     * @param chainNameOrId The name or id of the chain to target.
     * @returns A Validator with a default baseUrl.
     */
    static forChain(chainNameOrId) {
        const baseUrl = (0, index_js_1.getBaseUrl)(chainNameOrId);
        return new Validator({ baseUrl });
    }
    /**
     * Get health status
     * @description Returns OK if the validator considers itself healthy
     */
    async health(opts = {}) {
        return await (0, health_js_1.getHealth)(this.config, opts);
    }
    /**
     * Get version information
     * @description Returns version information about the validator daemon
     */
    async version(opts = {}) {
        return await (0, version_js_1.getVersion)(this.config, opts);
    }
    /**
     * Get table information
     * @description Returns information about a single table, including schema information
     */
    async getTableById(params, opts = {}) {
        if (typeof params.chainId !== "number" ||
            typeof params.tableId !== "string") {
            throw new Error("cannot get table with invalid chain or table id");
        }
        return await (0, tables_js_1.getTable)(this.config, params);
    }
    async queryByStatement(params, opts = {}) {
        return await (0, query_js_1.getQuery)(this.config, params, opts);
    }
    /**
     * Get transaction status
     * @description Returns the status of a given transaction receipt by hash
     */
    async receiptByTransactionHash(params, opts = {}) {
        return await (0, receipt_js_1.getTransactionReceipt)(this.config, params, opts);
    }
    /**
     * Wait for transaction status
     * @description Polls for the status of a given transaction receipt by hash until
     */
    async pollForReceiptByTransactionHash(params, opts = {}) {
        return await (0, receipt_js_1.pollTransactionReceipt)(this.config, params, opts);
    }
}
exports.Validator = Validator;
//# sourceMappingURL=index.js.map