import { type Config, type Signal, type ReadConfig } from "./helpers/index.js";
import { type Runnable } from "./registry/run.js";
import { type ExtractedStatement, type WaitableTransactionReceipt } from "./registry/utils.js";
import { type ObjectsFormat, type ValueOf } from "./validator/query.js";
export declare function exec(config: Config, { type, sql, tables: [first] }: ExtractedStatement): Promise<WaitableTransactionReceipt>;
/**
 * This is an internal method that will call the Registry Contract `mutate` method
 * with a set of Runnables.
 * Once the contract call finishes, this returns the mapping of the contract tx results
 * to the Runnables argument.
 */
export declare function execMutateMany(config: Config, runnables: Runnable[]): Promise<WaitableTransactionReceipt>;
/**
 * This is an internal method that will call the Registry Contract `create` method with
 * a set of sql create statements.
 * Once the contract call finishes, this returns the mapping of the contract tx results to
 * the create statements.
 */
export declare function execCreateMany(config: Config, statements: string[]): Promise<WaitableTransactionReceipt>;
export declare function errorWithCause(code: string, cause: Error): Error;
export declare function errorWithHint(statement: string, cause: Error): Error;
export declare function queryRaw<T = unknown>(config: ReadConfig, statement: string, opts?: Signal): Promise<Array<ValueOf<T>>>;
export declare function queryAll<T = unknown>(config: ReadConfig, statement: string, opts?: Signal): Promise<ObjectsFormat<T>>;
export declare function queryFirst<T = unknown>(config: ReadConfig, statement: string, opts?: Signal): Promise<T | null>;
export declare function extractColumn<T = unknown, K extends keyof T = keyof T>(values: T, colName: K): T[K];
export declare function extractColumn<T = unknown, K extends keyof T = keyof T>(values: T[], colName: K): Array<T[K]>;
//# sourceMappingURL=lowlevel.d.ts.map