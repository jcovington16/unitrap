import { type TransactionReceipt } from "../validator/receipt.js";
import { type Runnable } from "../registry/index.js";
import { type Wait } from "../helpers/await.js";
import { type Config, type ReadConfig } from "../helpers/config.js";
import { type ContractTransaction } from "../helpers/ethers.js";
import { type StatementType } from "../helpers/parser.js";
/**
 * WaitableTransactionReceipt represents a named TransactionReceipt with a wait method.
 * See the Validator spec in the docs for more details.
 * @typedef {Object} WaitableTransactionReceipt
 * @property {function} wait - Async function that will not return until the validator has processed tx.
 * @property {string} name - The full table name.
 * @property {string} prefix - The table name prefix.
 * @property {number} chainId - The chainId of tx.
 * @property {string} tableId - The tableId of tx.
 * @property {string} transaction_hash - The transaction hash of tx.
 * @property {number} block_number - The block number of tx.
 * @property {Object} error - The first error encounntered when the Validator processed tx.
 * @property {number} error_event_idx - The index of the event that cause the error when the Validator processed tx.
 */
export type WaitableTransactionReceipt = TransactionReceipt & Wait<TransactionReceipt & Named> & Named;
/**
 * Named represents a named table with a prefix.
 */
export interface Named {
    /**
     * @custom:deprecated First table's full name.
     */
    name: string;
    /**
     * @custom:deprecated First table name prefix.
     */
    prefix: string;
    /**
     * The full table names
     */
    names: string[];
    /**
     * The table prefixes
     */
    prefixes: string[];
}
/**
 * ExtractedStatement represents a SQL statement string with the type and tables extracted.
 */
export interface ExtractedStatement {
    /**
     * SQL statement string.
     */
    sql: string;
    /**
     * List of table names referenced within the statement.
     */
    tables: string[];
    /**
     * The statement type. Must be one of "read", "write", "create", or "acl".
     */
    type: StatementType;
}
export declare function wrapResult<T = unknown>(resultsOrReceipt: T[] | WaitableTransactionReceipt, duration: number): Result<T>;
/**
 * Metadata represents meta information about an executed statement/transaction.
 */
export interface Metadata {
    /**
     * Total client-side duration of the async call.
     */
    duration: number;
    /**
     * The optional transactionn information receipt.
     */
    txn?: WaitableTransactionReceipt;
    /**
     * Metadata may contrain additional arbitrary key/values pairs.
     */
    [key: string]: any;
}
/**
 * Result represents the core return result for an executed statement.
 */
export interface Result<T = unknown> {
    /**
     * Possibly empty list of query results.
     */
    results: T[];
    /**
     * Whether the query or transaction was successful.
     */
    success: boolean;
    /**
     * If there was an error, this will contain the error string.
     */
    error?: string;
    /**
     * Additional meta information.
     */
    meta: Metadata;
}
export declare function extractReadonly(conn: Config, { tables, type }: Omit<ExtractedStatement, "sql">): Promise<ReadConfig>;
/**
 * Given a config, a table name prefix, and a transaction that only affects a single table
 * this will enable waiting for the Validator to materialize the change in the transaction
 * @param {Object} conn - A Database config.
 * @param {string} prefix - A table name prefix.
 * @param {Object} tx - A transaction object that includes a call to the Registry Contract.
 * @returns {WaitableTransactionReceipt}
 */
export declare function wrapTransaction(conn: Config, prefix: string, tx: ContractTransaction): Promise<WaitableTransactionReceipt>;
export declare function wrapManyTransaction(conn: Config, statements: string[] | Runnable[], tx: ContractTransaction): Promise<WaitableTransactionReceipt & Named>;
//# sourceMappingURL=utils.d.ts.map