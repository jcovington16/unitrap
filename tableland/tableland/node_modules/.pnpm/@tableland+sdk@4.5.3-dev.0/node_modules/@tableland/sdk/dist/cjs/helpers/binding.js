"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindValues = exports.getParameters = exports.placeholderRegExp = void 0;
// Regexp to extract any placeholder types (?, ?NNN, @AAA, $AAA, or :AAA ) that are
// _not_ within quotes (", ', `) or [] "escapes". This works by having two top level
// "groups" that are or'd together. The first group is non-capturing, and catches quotes
// and escapes, and the second group is capturing, and catches all the placeholder types
exports.placeholderRegExp = /(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|`(?:[^`\\]|\\.)*`|\[(?:[^[\\]|\\.)*\])|(\?\d*|[:@$][a-zA-Z_]\w+)/gmu;
function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null)
        return false;
    const proto = Object.getPrototypeOf(obj);
    return proto !== null && Object.getPrototypeOf(proto) === null;
}
function bindString(param, quoteEscaper = "''") {
    return "'" + param.replace(/'/g, quoteEscaper) + "'";
}
function bindBoolean(param) {
    return Number(param).toString();
}
function bindNumber(param) {
    return param.toString();
}
function bindDate(param) {
    return param.valueOf().toString();
}
function bindBytes(param) {
    const hex = param.reduce((t, x) => t + x.toString(16).padStart(2, "0"), "");
    return `X'${hex}'`;
}
function bindObject(param) {
    return bindString(JSON.stringify(param));
}
function bindNull(_param) {
    return "NULL";
}
function bindToString(param) {
    return bindString(String(param));
}
function isSQL(param) {
    return typeof param.toSQL === "function";
}
function bindToSQL(param) {
    return param.toSQL();
}
function bindValue(param) {
    switch (typeof param) {
        case "bigint":
        case "number":
            return bindNumber(param);
        case "boolean":
            return bindBoolean(param);
        case "string":
            return bindString(param);
        case "undefined":
            return bindNull(param);
        case "object":
            if (param instanceof Date) {
                return bindDate(param);
            }
            else if (param instanceof Uint8Array) {
                return bindBytes(param);
            }
            else if (param == null) {
                return bindNull(param);
            }
            else if (isPlainObject(param)) {
                return bindObject(param);
            }
            else if (isSQL(param)) {
                return bindToSQL(param);
                /* c8 ignore next 3 */
            }
            else {
                return bindToString(param);
            }
        default:
            return bindToString(param);
    }
}
function getParameters(...values) {
    const initialValue = { anon: [], named: {} };
    const flat = values.flat(Infinity);
    const result = flat.reduce(({ anon, named }, v) => {
        if (isPlainObject(v)) {
            return { anon, named: { ...named, ...v } };
        }
        else {
            return { anon: [...anon, v], named };
        }
    }, initialValue);
    return result;
}
exports.getParameters = getParameters;
function bindValues(sql, parameters) {
    // https://sqlite.org/forum/forumpost/4350e973ad
    if (parameters == null) {
        return sql;
    }
    const { anon, named } = parameters;
    let bindIndex = 0;
    const seen = new Set();
    const a = anon;
    const n = named ?? {};
    const replaced = sql.replace(exports.placeholderRegExp, function (m, group) {
        if (group == null) {
            return m;
        }
        if (group === "?") {
            return bindValue(a[bindIndex++]);
        }
        else if (/\?\d*/.test(group)) {
            const index = parseInt(group.slice(1)) - 1;
            if (index >= bindIndex) {
                bindIndex = index + 1;
            }
            return bindValue(a[index]);
        }
        else if (/[:@$][a-zA-Z_]\w+/g.test(group)) {
            const key = group.slice(1);
            seen.add(key);
            return bindValue(n[key]);
            /* c8 ignore next 3 */
        }
        else {
            return m;
        }
    });
    const expectedParams = bindIndex + seen.size;
    const receivedParams = a.length + Object.keys(n).length;
    if (expectedParams !== receivedParams) {
        throw new Error(`parameter mismatch: received (${receivedParams}), expected ${expectedParams}`);
    }
    return replaced;
}
exports.bindValues = bindValues;
//# sourceMappingURL=binding.js.map