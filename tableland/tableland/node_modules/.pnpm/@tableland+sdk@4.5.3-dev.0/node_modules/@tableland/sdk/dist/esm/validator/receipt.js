import { camelize, } from "../helpers/utils.js";
import { getAsyncPoller, } from "../helpers/await.js";
import { hoistApiError } from "./errors.js";
import { getFetcher, ApiError, } from "./client/index.js";
function assertResponse(obj) {
    return (obj.block_number != null &&
        obj.chain_id != null &&
        obj.transaction_hash != null &&
        /* c8 ignore next */
        (obj.table_id != null || obj.error != null || obj.error_event_idx != null));
}
function transformResponse(obj) {
    if (assertResponse(obj)) {
        return camelize(obj);
    }
    /* c8 ignore next 2 */
    throw new Error("malformed transaction receipt response");
}
export async function getTransactionReceipt(config, params, opts = {}) {
    const receiptByTransactionHash = getFetcher(config)
        .path("/receipt/{chainId}/{transactionHash}")
        .method("get")
        .create();
    const { data } = await receiptByTransactionHash(params, opts).catch(hoistApiError);
    const transformed = transformResponse(data);
    return transformed;
}
export async function pollTransactionReceipt(config, params, { signal, interval } = {}) {
    const receiptByTransactionHash = getFetcher(config)
        .path("/receipt/{chainId}/{transactionHash}")
        .method("get")
        .create();
    const fn = async () => {
        try {
            const { data: obj } = await receiptByTransactionHash(params, {
                signal,
            }).catch(hoistApiError);
            const data = transformResponse(obj);
            return { done: true, data };
        }
        catch (err) {
            if (err instanceof ApiError && err.status === 404) {
                return { done: false };
            }
            /* c8 ignore next */
            throw err;
        }
    };
    const receipt = await getAsyncPoller(fn, interval, signal);
    return receipt;
}
//# sourceMappingURL=receipt.js.map