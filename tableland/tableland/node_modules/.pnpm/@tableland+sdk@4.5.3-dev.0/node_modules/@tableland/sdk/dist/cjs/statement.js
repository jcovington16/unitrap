"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Statement_instances, _Statement_parseAndExtract, _Statement_waitExec;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Statement = void 0;
const binding_js_1 = require("./helpers/binding.js");
const index_js_1 = require("./helpers/index.js");
const utils_js_1 = require("./registry/utils.js");
const lowlevel_js_1 = require("./lowlevel.js");
/**
 * Statement defines a single SQL statement.
 * Both static and prepared statements are supported. In the current
 * implementation, the prepared statements are prepared locally, and
 * executed remotely (on-chain).
 * Mutating transactions such as INSERTs, DELETEs, and UPDATEs produce
 * a two-phase transaction. Firstly, the transaction is sent to the
 * registry contract, and awaited. The returned `txn` information also
 * contains a `wait` method than can be used to await finalization on
 * the Tableland network. This method will also throw an exception if
 * any runtime errors occur.
 */
class Statement {
    constructor(config, sql, parameters) {
        _Statement_instances.add(this);
        if (typeof sql !== "string") {
            throw new Error("SQL statement must be a String");
        }
        this.config = config;
        this.sql = sql.trim();
        this.parameters = parameters;
    }
    /**
     * Bind a set of values to the parameters of the prepared statement.
     * We follow the SQLite convention for prepared statements parameter binding.
     * We support Ordered (?NNNN), Anonymous (?), and Named (@name, :name, $name) parameters.
     * @param values A variadic list of values to bind. May include base types, and objects.
     * @returns A new bound Statement.
     */
    bind(...values) {
        const parameters = (0, binding_js_1.getParameters)(...values);
        return new Statement(this.config, this.sql, parameters);
    }
    /**
     * Resolve a bound statement to a SQL string.
     * @returns A valid SQL string.
     */
    toString() {
        try {
            return (0, binding_js_1.bindValues)(this.sql, this.parameters);
        }
        catch (cause) {
            const hint = (0, lowlevel_js_1.errorWithHint)(this.sql, cause);
            throw (0, lowlevel_js_1.errorWithCause)("BIND_ERROR", hint);
        }
    }
    /**
     * Export a Statement's sql string and parameters.
     * @returns
     */
    toObject() {
        return {
            sql: this.sql,
            parameters: this.parameters,
        };
    }
    async all(colName, opts = {}) {
        try {
            const start = performance.now();
            const { sql, type, tables } = await __classPrivateFieldGet(this, _Statement_instances, "m", _Statement_parseAndExtract).call(this);
            switch (type) {
                case "read": {
                    const config = await (0, utils_js_1.extractReadonly)(this.config, {
                        type,
                        tables,
                    });
                    const results = await (0, lowlevel_js_1.queryAll)(config, sql, opts);
                    if (colName != null) {
                        return (0, utils_js_1.wrapResult)((0, lowlevel_js_1.extractColumn)(results, colName), performance.now() - start);
                    }
                    return (0, utils_js_1.wrapResult)(results, performance.now() - start);
                }
                default: {
                    return (0, utils_js_1.wrapResult)(await __classPrivateFieldGet(this, _Statement_instances, "m", _Statement_waitExec).call(this, { ...opts, type, sql, tables }), performance.now() - start);
                }
            }
        }
        catch (cause) {
            const hint = (0, lowlevel_js_1.errorWithHint)(this.sql, cause);
            throw (0, lowlevel_js_1.errorWithCause)("ALL_ERROR", hint);
        }
    }
    async first(colName, opts = {}) {
        try {
            const { sql, type, tables } = await __classPrivateFieldGet(this, _Statement_instances, "m", _Statement_parseAndExtract).call(this);
            switch (type) {
                case "read": {
                    const config = await (0, utils_js_1.extractReadonly)(this.config, {
                        type,
                        tables,
                    });
                    const results = await (0, lowlevel_js_1.queryFirst)(config, sql, opts);
                    if (results == null || colName == null) {
                        return results;
                    }
                    return (0, lowlevel_js_1.extractColumn)(results, colName);
                }
                default: {
                    await __classPrivateFieldGet(this, _Statement_instances, "m", _Statement_waitExec).call(this, {
                        ...opts,
                        type,
                        sql,
                        tables,
                    });
                    return null;
                }
            }
        }
        catch (cause) {
            const hint = (0, lowlevel_js_1.errorWithHint)(this.sql, cause);
            throw (0, lowlevel_js_1.errorWithCause)("FIRST_ERROR", hint);
        }
    }
    /**
     * Runs the query/queries, but returns no results. Instead, run()
     * returns the metrics only. Useful for write operations like
     * UPDATE, DELETE or INSERT.
     * @param opts Additional options to control execution.
     * @returns A results object with metadata only (results are null or an empty array).
     */
    async run(opts = {}) {
        try {
            const start = performance.now();
            const { sql, type, tables } = await __classPrivateFieldGet(this, _Statement_instances, "m", _Statement_parseAndExtract).call(this);
            switch (type) {
                case "read": {
                    const config = await (0, utils_js_1.extractReadonly)(this.config, {
                        type,
                        tables,
                    });
                    const results = await (0, lowlevel_js_1.queryAll)(config, sql, opts);
                    return (0, utils_js_1.wrapResult)(results, performance.now() - start);
                }
                default: {
                    return (0, utils_js_1.wrapResult)(await __classPrivateFieldGet(this, _Statement_instances, "m", _Statement_waitExec).call(this, { ...opts, type, sql, tables }), performance.now() - start);
                }
            }
        }
        catch (cause) {
            const hint = (0, lowlevel_js_1.errorWithHint)(this.sql, cause);
            throw (0, lowlevel_js_1.errorWithCause)("RUN_ERROR", hint);
        }
    }
    /**
     * Same as stmt.all(), but returns an array of rows instead of objects.
     * @param opts Additional options to control execution.
     * @returns An array of raw query results.
     */
    async raw(opts = {}) {
        try {
            const { sql, type, tables } = await __classPrivateFieldGet(this, _Statement_instances, "m", _Statement_parseAndExtract).call(this);
            switch (type) {
                case "read": {
                    const config = await (0, utils_js_1.extractReadonly)(this.config, {
                        type,
                        tables,
                    });
                    return await (0, lowlevel_js_1.queryRaw)(config, sql, opts);
                }
                default: {
                    await __classPrivateFieldGet(this, _Statement_instances, "m", _Statement_waitExec).call(this, {
                        ...opts,
                        type,
                        sql,
                        tables,
                    });
                    return [];
                }
            }
        }
        catch (cause) {
            const hint = (0, lowlevel_js_1.errorWithHint)(this.sql, cause);
            throw (0, lowlevel_js_1.errorWithCause)("RAW_ERROR", hint);
        }
    }
}
exports.Statement = Statement;
_Statement_instances = new WeakSet(), _Statement_parseAndExtract = async function _Statement_parseAndExtract() {
    const statementWithBindings = this.toString();
    const nameMap = typeof this.config.aliases?.read === "function"
        ? await this.config.aliases.read()
        : undefined;
    const { type, statements, tables } = await (0, index_js_1.normalize)(statementWithBindings, nameMap);
    // TODO: this feels wrong, but we have to use the normalize function to determine the type,
    //    then use it again if the type is create to ensure that a new table isn't created with
    //    an existing prefix.
    if (type === "create" && nameMap != null) {
        const { tables } = await (0, index_js_1.normalize)(statementWithBindings);
        // if the table prefix already exists throw an error
        if (tables.find((table) => table in nameMap) != null) {
            throw new Error("table name already exists in aliases");
        }
    }
    // Stick with original if a create statement, otherwise, use the parsed version
    // This is because the parser injects keywords that are not spec compliant
    // See https://github.com/tablelandnetwork/go-sqlparser/issues/41
    const sql = type === "create" ? statementWithBindings : statements.join(";");
    return { type, sql, tables };
}, _Statement_waitExec = async function _Statement_waitExec(params) {
    return await (0, index_js_1.checkWait)(this.config, await (0, lowlevel_js_1.exec)(this.config, params));
};
//# sourceMappingURL=statement.js.map