"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContractSetup = exports.assertChainId = exports.getContractAndOverrides = exports.getTableIdentifier = void 0;
const evm_1 = require("@tableland/evm");
const ethers_js_1 = require("../helpers/ethers.js");
const parser_js_1 = require("../helpers/parser.js");
const chains_js_1 = require("../helpers/chains.js");
const connect = evm_1.TablelandTables__factory.connect;
async function getTableIdentifier(tableName) {
    const { tableId, chainId } = typeof tableName === "string"
        ? await (0, parser_js_1.validateTableName)(tableName)
        : tableName;
    return { tableId: tableId.toString(), chainId };
}
exports.getTableIdentifier = getTableIdentifier;
async function getContractAndOverrides(signer, chainId) {
    const address = (0, chains_js_1.getContractAddress)(chainId);
    signer._checkProvider();
    const contract = connect(address, signer);
    const overrides = await (0, ethers_js_1.getOverrides)({ signer });
    return { contract, overrides };
}
exports.getContractAndOverrides = getContractAndOverrides;
function assertChainId(actual, expected) {
    if (actual !== expected && expected != null) {
        throw new Error(`chain id mismatch: received ${actual}, expected ${expected}`);
    }
    return actual;
}
exports.assertChainId = assertChainId;
async function getContractSetup(signer, tableName) {
    const { chainId: chain, tableId } = await getTableIdentifier(tableName);
    const chainId = await signer.getChainId();
    assertChainId(chainId, chain);
    const { contract, overrides } = await getContractAndOverrides(signer, chainId);
    return { contract, overrides, tableId };
}
exports.getContractSetup = getContractSetup;
//# sourceMappingURL=contract.js.map