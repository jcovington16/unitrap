"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultProvider = exports.getSigner = exports.getContractReceipt = exports.getOverrides = void 0;
const ethers_1 = require("ethers");
const { getDefaultProvider, Web3Provider } = ethers_1.providers;
exports.getDefaultProvider = getDefaultProvider;
/**
 * Request a set of opinionated overrides to be used when calling the Tableland contract.
 * @param signer A valid web3 provider/signer.
 * @returns A promise that resolves to an object with overrides.
 */
async function getOverrides({ signer, }) {
    // Hack: Revert to gasPrice to avoid always underpriced eip-1559 transactions on Polygon
    const opts = {};
    const network = await signer.provider?.getNetwork();
    /* c8 ignore next 7 */
    if (network?.chainId === 137) {
        const feeData = await signer.getFeeData();
        if (feeData.gasPrice != null) {
            opts.gasPrice =
                Math.floor(feeData.gasPrice.toNumber() * 1.1) ?? undefined;
        }
    }
    return opts;
}
exports.getOverrides = getOverrides;
/**
 *
 * Given a transaction, this helper will return the tableIds that were part of the transaction.
 * Especially useful for transactions that create new tables because you need the tableId to
 * calculate the full table name.
 * @param {tx} a contract transaction
 * @returns {MultiEventTransactionReceipt} tableland receipt
 *
 */
async function getContractReceipt(tx) {
    const receipt = await tx.wait();
    /* c8 ignore next */
    const events = receipt.events ?? [];
    const transactionHash = receipt.transactionHash;
    const blockNumber = receipt.blockNumber;
    const chainId = tx.chainId;
    const tableIds = [];
    for (const event of events) {
        const tableId = event.args?.tableId != null && event.args.tableId.toString();
        switch (event.event) {
            case "CreateTable":
            case "RunSQL":
                if (tableId != null)
                    tableIds.push(tableId);
                break;
            default:
            // Could be a Transfer or other
        }
    }
    return { tableIds, transactionHash, blockNumber, chainId };
}
exports.getContractReceipt = getContractReceipt;
/**
 * Request a signer object from the global ethereum object.
 * @param external A valid external provider. Defaults to `globalThis.ethereum` if not provided.
 * @returns A promise that resolves to a valid web3 provider/signer
 * @throws If no global ethereum object is available.
 */
async function getSigner(external) {
    const provider = external ?? globalThis.ethereum;
    if (provider == null) {
        throw new Error("provider error: missing global ethereum provider");
    }
    if (provider.request == null) {
        throw new Error("provider error: missing request method on ethereum provider");
    }
    await provider.request({ method: "eth_requestAccounts" });
    const web3Provider = new Web3Provider(provider);
    return web3Provider.getSigner();
}
exports.getSigner = getSigner;
//# sourceMappingURL=ethers.js.map