"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractColumn = exports.queryFirst = exports.queryAll = exports.queryRaw = exports.errorWithHint = exports.errorWithCause = exports.execCreateMany = exports.execMutateMany = exports.exec = void 0;
const index_js_1 = require("./helpers/index.js");
const create_js_1 = require("./registry/create.js");
const run_js_1 = require("./registry/run.js");
const utils_js_1 = require("./registry/utils.js");
const query_js_1 = require("./validator/query.js");
const index_js_2 = require("./validator/index.js");
// see `errorWithHint` for usage
const hints = [
    {
        regexp: /syntax error at position \d+ near '.+'/,
        template: function (statement, match) {
            const location = Number(match.input.slice(match.index).split(" ")[4]);
            if (isNaN(location))
                return "";
            const termMatch = match.input.match(/syntax error at position \d+ (near '.+')/);
            if (termMatch == null ||
                termMatch.length < 1 ||
                termMatch[1].indexOf("near '") !== 0) {
                return "";
            }
            // isolate the term from the matched string
            const term = termMatch[1].slice(6, -1);
            const padding = " ".repeat(location - term.length);
            const carrots = "^".repeat(term.length);
            return `${statement}
${padding}${carrots}`;
        },
    },
    {
        regexp: /no such column/,
        template: function (statement, match) {
            // note: the error returned from the validator, and the one generated in the client
            // in the client already include the name of the column.
            return statement;
        },
    },
];
// TODO: this only works if the transaction will only be affecting a single table.
//       I've currently got new versions of this below called execMutateMany and
//       execCreateMany, but we might be able to combine all of these `exec` functions
//       into one when we move to version 5.
async function exec(config, { type, sql, tables: [first] }) {
    const signer = await (0, index_js_1.extractSigner)(config);
    const chainId = await signer.getChainId();
    const baseUrl = await (0, index_js_1.extractBaseUrl)(config, chainId);
    const _config = { baseUrl, signer };
    const _params = { chainId, first, statement: sql };
    switch (type) {
        case "create": {
            if (typeof config.aliases?.read === "function") {
                const currentAliases = await config.aliases.read();
                if (currentAliases[first] != null) {
                    throw new Error("table name already exists in aliases");
                }
            }
            const { prefix, ...prepared } = await (0, create_js_1.prepareCreateOne)(_params);
            const tx = await (0, create_js_1.create)(_config, prepared);
            const wrappedTx = await (0, utils_js_1.wrapTransaction)(_config, prefix, tx);
            if (typeof config.aliases?.write === "function") {
                const uuTableName = wrappedTx.name;
                const nameMap = {};
                nameMap[first] = uuTableName;
                await config.aliases.write(nameMap);
            }
            return wrappedTx;
        }
        /* c8 ignore next */
        case "acl":
        case "write": {
            if (typeof config.aliases?.read === "function") {
                const nameMap = await config.aliases.read();
                const norm = await (0, index_js_1.normalize)(_params.statement, nameMap);
                _params.statement = norm.statements[0];
                _params.first = nameMap[first] != null ? nameMap[first] : first;
            }
            const { prefix, ...prepared } = await (0, run_js_1.prepareMutateOne)(_params);
            const tx = await (0, run_js_1.mutate)(_config, prepared);
            return await (0, utils_js_1.wrapTransaction)(_config, prefix, tx);
        }
        /* c8 ignore next 2 */
        default:
            throw new Error("invalid statement type: read");
    }
}
exports.exec = exec;
/**
 * This is an internal method that will call the Registry Contract `mutate` method
 * with a set of Runnables.
 * Once the contract call finishes, this returns the mapping of the contract tx results
 * to the Runnables argument.
 */
async function execMutateMany(config, runnables) {
    const signer = await (0, index_js_1.extractSigner)(config);
    const chainId = await signer.getChainId();
    const baseUrl = await (0, index_js_1.extractBaseUrl)(config, chainId);
    const _config = { baseUrl, signer };
    const params = { runnables, chainId };
    if (typeof config.aliases?.read === "function") {
        const nameMap = await config.aliases.read();
        params.runnables = await Promise.all(params.runnables.map(async function (runnable) {
            const norm = await (0, index_js_1.normalize)(runnable.statement, nameMap);
            runnable.statement = norm.statements[0];
            return runnable;
        }));
    }
    const tx = await (0, run_js_1.mutate)(_config, params);
    return await (0, utils_js_1.wrapManyTransaction)(_config, runnables.map((r) => r.statement), tx);
}
exports.execMutateMany = execMutateMany;
/**
 * This is an internal method that will call the Registry Contract `create` method with
 * a set of sql create statements.
 * Once the contract call finishes, this returns the mapping of the contract tx results to
 * the create statements.
 */
async function execCreateMany(config, statements) {
    const signer = await (0, index_js_1.extractSigner)(config);
    const chainId = await signer.getChainId();
    const baseUrl = await (0, index_js_1.extractBaseUrl)(config, chainId);
    const _config = { baseUrl, signer };
    const params = {
        statements: await Promise.all(statements.map(async function (statement) {
            const prepared = await (0, create_js_1.prepareCreateOne)({ statement, chainId });
            return prepared.statement;
        })),
        chainId,
    };
    const tx = await (0, create_js_1.create)(_config, params);
    const wrappedTx = await (0, utils_js_1.wrapManyTransaction)(_config, statements, tx);
    if (typeof config.aliases?.write === "function") {
        const currentAliases = await config.aliases.read();
        // Collect the user provided table names to add to the aliases.
        const aliasesTableNames = await Promise.all(statements.map(async function (statement) {
            const norm = await (0, index_js_1.normalize)(statement);
            if (currentAliases[norm.tables[0]] != null) {
                throw new Error("table name already exists in aliases");
            }
            return norm.tables[0];
        }));
        const uuTableNames = wrappedTx.names;
        const nameMap = {};
        for (let i = 0; i < aliasesTableNames.length; i++) {
            nameMap[aliasesTableNames[i]] = uuTableNames[i];
        }
        await config.aliases.write(nameMap);
    }
    return wrappedTx;
}
exports.execCreateMany = execCreateMany;
function errorWithCause(code, cause) {
    return new Error(`${code}: ${cause.message}`, { cause });
}
exports.errorWithCause = errorWithCause;
function errorWithHint(statement, cause) {
    if (cause.message == null || statement == null)
        return cause;
    let errorMessage = cause.message;
    try {
        for (let i = 0; i < hints.length; i++) {
            const hint = hints[i];
            const match = errorMessage.match(hint.regexp);
            if (match == null)
                continue;
            const hintMessage = hint.template(statement, match);
            errorMessage += hintMessage !== "" ? `\n${hintMessage}` : "";
            break;
        }
        return new Error(errorMessage, { cause });
    }
    catch (err) {
        return cause;
    }
}
exports.errorWithHint = errorWithHint;
function catchNotFound(err) {
    if (err instanceof index_js_2.ApiError && err.status === 404) {
        return [];
    }
    throw err;
}
async function queryRaw(config, statement, opts = {}) {
    const params = { statement, format: "table" };
    const response = await (0, query_js_1.getQuery)(config, params, opts)
        .then((res) => res.rows)
        .catch(catchNotFound);
    return response;
}
exports.queryRaw = queryRaw;
async function queryAll(config, statement, opts = {}) {
    const params = { statement, format: "objects" };
    const response = await (0, query_js_1.getQuery)(config, params, opts).catch(catchNotFound);
    return response;
}
exports.queryAll = queryAll;
async function queryFirst(config, statement, opts = {}) {
    const response = await queryAll(config, statement, opts).catch(catchNotFound);
    return response.shift() ?? null;
}
exports.queryFirst = queryFirst;
function extractColumn(values, colName) {
    const array = Array.isArray(values) ? values : [values];
    return array.map((row) => {
        if (row[colName] === undefined) {
            throw new Error(`no such column: ${colName.toString()}`);
        }
        return row[colName];
    });
}
exports.extractColumn = extractColumn;
//# sourceMappingURL=lowlevel.js.map