import { type ValuesType, type Parameters, type BaseType } from "./helpers/binding.js";
import { type AutoWaitConfig, type Config, type SignalAndInterval } from "./helpers/index.js";
import { type Result } from "./registry/utils.js";
import { type ValueOf } from "./validator/query.js";
export { type ValuesType, type Parameters, type ValueOf, type BaseType };
/**
 * Statement defines a single SQL statement.
 * Both static and prepared statements are supported. In the current
 * implementation, the prepared statements are prepared locally, and
 * executed remotely (on-chain).
 * Mutating transactions such as INSERTs, DELETEs, and UPDATEs produce
 * a two-phase transaction. Firstly, the transaction is sent to the
 * registry contract, and awaited. The returned `txn` information also
 * contains a `wait` method than can be used to await finalization on
 * the Tableland network. This method will also throw an exception if
 * any runtime errors occur.
 */
export declare class Statement<S = unknown> {
    #private;
    private readonly config;
    private readonly sql;
    private readonly parameters?;
    constructor(config: Config & Partial<AutoWaitConfig>, sql: string, parameters?: Parameters);
    /**
     * Bind a set of values to the parameters of the prepared statement.
     * We follow the SQLite convention for prepared statements parameter binding.
     * We support Ordered (?NNNN), Anonymous (?), and Named (@name, :name, $name) parameters.
     * @param values A variadic list of values to bind. May include base types, and objects.
     * @returns A new bound Statement.
     */
    bind<T = S>(...values: ValuesType[]): Statement<T>;
    /**
     * Resolve a bound statement to a SQL string.
     * @returns A valid SQL string.
     */
    toString(): string;
    /**
     * Export a Statement's sql string and parameters.
     * @returns
     */
    toObject(): {
        sql: string;
        parameters?: Parameters;
    };
    /**
     * Executes a query and returns all rows and metadata.
     * @param colName If provided, filter results to the provided column.
     * @param opts Additional options to control execution.
     */
    all<T = S, K extends keyof T = keyof T>(colName?: undefined, opts?: SignalAndInterval): Promise<Result<T>>;
    all<T = S, K extends keyof T = keyof T>(colName: K, opts?: SignalAndInterval): Promise<Result<T[K]>>;
    /**
     * Executes a query and returns the first row of the results.
     * This does not return metadata like the other methods.
     * Instead it returns the object directly. If the query returns no
     * rows, then first() will return null.
     * @param colName If provided, filter results to the provided column.
     * @param opts Additional options to control execution.
     */
    first<T = S, K extends keyof T = keyof T>(): Promise<T>;
    first<T = S, K extends keyof T = keyof T>(colName: undefined, opts?: SignalAndInterval): Promise<T>;
    first<T = S, K extends keyof T = keyof T>(colName: K, opts?: SignalAndInterval): Promise<T[K] | null>;
    /**
     * Runs the query/queries, but returns no results. Instead, run()
     * returns the metrics only. Useful for write operations like
     * UPDATE, DELETE or INSERT.
     * @param opts Additional options to control execution.
     * @returns A results object with metadata only (results are null or an empty array).
     */
    run(opts?: SignalAndInterval): Promise<Result<never>>;
    /**
     * Same as stmt.all(), but returns an array of rows instead of objects.
     * @param opts Additional options to control execution.
     * @returns An array of raw query results.
     */
    raw<T = S>(opts?: SignalAndInterval): Promise<Array<ValueOf<T>>>;
}
//# sourceMappingURL=statement.d.ts.map