"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAsyncPoller = exports.getAbortSignal = void 0;
function getAbortSignal(signal, maxTimeout = 60000) {
    let abortSignal;
    let timeoutId;
    if (signal == null) {
        const controller = new AbortController();
        abortSignal = controller.signal;
        // return the timeoutId so the caller can cleanup
        timeoutId = setTimeout(function () {
            controller.abort();
        }, maxTimeout);
    }
    else {
        abortSignal = signal;
    }
    return { signal: abortSignal, timeoutId };
}
exports.getAbortSignal = getAbortSignal;
async function getAsyncPoller(fn, interval = 1500, signal) {
    // in order to set a timeout other than 10 seconds you need to
    // create and pass in an abort signal with a different timeout
    const { signal: abortSignal, timeoutId } = getAbortSignal(signal, 10000);
    const checkCondition = (resolve, reject) => {
        Promise.resolve(fn())
            .then((result) => {
            if (result.done && result.data != null) {
                // We don't want to call `AbortController.abort()` if the call succeeded
                clearTimeout(timeoutId);
                return resolve(result.data);
            }
            if (abortSignal.aborted) {
                // We don't want to call `AbortController.abort()` if the call is already aborted
                clearTimeout(timeoutId);
                return reject(abortSignal.reason);
            }
            else {
                setTimeout(checkCondition, interval, resolve, reject);
            }
        })
            .catch((err) => {
            return reject(err);
        });
    };
    return await new Promise(checkCondition);
}
exports.getAsyncPoller = getAsyncPoller;
//# sourceMappingURL=await.js.map