"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTables = exports.validateTableName = exports.normalize = void 0;
const sqlparser_1 = require("@tableland/sqlparser");
const chains_js_1 = require("./chains.js");
async function normalize(sql, nameMap) {
    if (typeof sql !== "string") {
        throw new Error("SQL statement must be a String");
    }
    /* c8 ignore next 3 */
    if (sqlparser_1.__wasm == null) {
        await (0, sqlparser_1.init)();
    }
    return await sqlparser.normalize(sql, nameMap);
}
exports.normalize = normalize;
async function validateTableName(tableName, isCreate = false) {
    if (typeof tableName !== "string") {
        throw new Error("table name must be a String");
    }
    /* c8 ignore next 3 */
    if (sqlparser_1.__wasm == null) {
        await (0, sqlparser_1.init)();
    }
    return await sqlparser.validateTableName(tableName, isCreate);
}
exports.validateTableName = validateTableName;
async function validateTables({ tables, type, }) {
    /* c8 ignore next 3 */
    if (sqlparser_1.__wasm == null) {
        await (0, sqlparser_1.init)();
    }
    const validatedTables = await Promise.all(tables.map(async (tableName) => await sqlparser.validateTableName(tableName, type === "create")));
    const same = validatedTables
        .map((tbl) => (0, chains_js_1.isTestnet)(tbl.chainId))
        /* c8 ignore next */
        .reduce((a, b) => (a === b ? a : null));
    if (same == null) {
        throw new Error("network mismatch: mix of testnet and mainnet chains");
    }
    return validatedTables;
}
exports.validateTables = validateTables;
//# sourceMappingURL=parser.js.map