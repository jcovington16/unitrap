import { type SignerConfig, type Signer, type ContractTransaction } from "../helpers/index.js";
import { type TableIdentifier } from "./contract.js";
import { type TransferParams } from "./transfer.js";
import { type SetParams } from "./controller.js";
import { type CreateOneParams, type CreateManyParams, type CreateParams } from "./create.js";
import { type Runnable, type RunSQLParams, type MutateManyParams, type MutateOneParams, type MutateParams } from "./run.js";
export { type Result, type Metadata, type WaitableTransactionReceipt, type Named, } from "./utils.js";
export { type TableIdentifier, type CreateOneParams as CreateTableParams, // deprecated
type CreateOneParams, type CreateManyParams, type CreateParams, type MutateOneParams, type MutateManyParams, type MutateParams, type RunSQLParams, // deprecated
type Runnable, type TransferParams, type SetParams, };
/**
 * Registry provides direct access to remote Registry smart contract APIs.
 */
export declare class Registry {
    readonly config: SignerConfig;
    /**
     * Create a Registry instance with the specified connection configuration.
     * @param config The connection configuration. This must include an ethersjs
     * Signer. If passing the config from a pre-existing Database instance, it
     * must have a non-null signer key defined.
     */
    constructor(config?: Partial<SignerConfig>);
    /**
     * Create a Registry that is connected to the given Signer.
     * @param signer An ethersjs Signer to use for mutating queries.
     */
    static forSigner(signer: Signer): Promise<Registry>;
    /**
     * Gets the list of table IDs of the requested owner.
     * @param owner The address owning the table.
     */
    listTables(owner?: string): Promise<TableIdentifier[]>;
    /**
     * Safely transfers the ownership of a given table ID to another address.
     *
     * Requires the msg sender to be the owner, approved, or operator
     */
    safeTransferFrom(params: TransferParams): Promise<ContractTransaction>;
    /**
     * Sets the controller for a table. Controller can be an EOA or contract address.
     *
     * When a table is created, it's controller is set to the zero address, which means that the
     * contract will not enforce write access control. In this situation, validators will not accept
     * transactions from non-owners unless explicitly granted access with "GRANT" SQL statements.
     *
     * When a controller address is set for a table, validators assume write access control is
     * handled at the contract level, and will accept all transactions.
     *
     * You can unset a controller address for a table by setting it back to the zero address.
     * This will cause validators to revert back to honoring owner and GRANT bases write access control.
     *
     * caller - the address that is setting the controller
     * tableId - the id of the target table
     * controller - the address of the controller (EOA or contract)
     *
     * Requirements:
     *
     * - contract must be unpaused
     * - `msg.sender` must be `caller` or contract owner and owner of `tableId`
     * - `tableId` must exist
     * - `tableId` controller must not be locked
     */
    setController(params: SetParams): Promise<ContractTransaction>;
    /**
     * Locks the controller for a table _forever_. Controller can be an EOA or contract address.
     *
     * Although not very useful, it is possible to lock a table controller that is set to the zero address.
     *
     * caller - the address that is locking the controller
     * tableId - the id of the target table
     *
     * Requirements:
     *
     * - contract must be unpaused
     * - `msg.sender` must be `caller` or contract owner and owner of `tableId`
     * - `tableId` must exist
     * - `tableId` controller must not be locked
     */
    lockController(table: string | TableIdentifier): Promise<ContractTransaction>;
    /**
     * Returns the controller for a table.
     *
     * tableId - the id of the target table
     */
    getController(table: string | TableIdentifier): Promise<string>;
    /**
     * Creates a new table owned by `owner` using `statement` and returns its `tableId`.
     *
     * owner - the to-be owner of the new table
     * statement - the SQL statement used to create the table
     *
     * Requirements:
     *
     * - contract must be unpaused
     */
    create(params: CreateParams): Promise<ContractTransaction>;
    /**
     * @custom:deprecated Use `create` instead.
     */
    createTable(params: CreateOneParams): Promise<ContractTransaction>;
    /**
     * Runs a SQL statement for `caller` using `statement`.
     *
     * caller - the address that is running the SQL statement
     * tableId - the id of the target table
     * statement - the SQL statement to run
     *
     * Requirements:
     *
     * - contract must be unpaused
     * - `msg.sender` must be `caller`
     * - `tableId` must exist
     * - `caller` must be authorized by the table controller
     * - `statement` must be less than 35000 bytes after normalizing
     */
    mutate(params: MutateParams): Promise<ContractTransaction>;
    /**
     * Runs a set of SQL statements for `caller` using `runnables`.
     * @custom:deprecated Using this with a single statement is deprecated. Use `mutate` instead.
     */
    runSQL(params: MutateParams): Promise<ContractTransaction>;
}
//# sourceMappingURL=index.d.ts.map