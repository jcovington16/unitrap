import { type Result } from "./registry/index.js";
import { type Config, type AutoWaitConfig, type ChainName, type Signal, type Signer } from "./helpers/index.js";
import { Statement } from "./statement.js";
/**
 * Database is the primary API for accessing the Tabeland network as a database.
 * This class provides a small and simple API that will feel very familiar to
 * web2 database users. It includes the concept of prepared statements, SQL
 * parameter binding, execution and query modes, and more. It is actually similar
 * to the better-sqlite3, and D1 APIs in many respects.
 */
export declare class Database<D = unknown> {
    readonly config: Config & Partial<AutoWaitConfig>;
    /**
     * Create a Database instance with the specified connection configuration.
     * @param config The connection configuration. These keys are evaluated lazily,
     * so it is possible to omit the baseUrl or signer, depending on your query
     * needs. For a read-only Database for instance, only the baseUrl needs to be
     * provided.
     */
    constructor(config?: Config & Partial<AutoWaitConfig>);
    /**
     * Create a Database that uses the default baseUrl for a given chain.
     * @deprecated since 4.0.1, will be deleted in 5.0.0
     * @param chainNameOrId The name or id of the chain to target.
     * @returns A Database without a signer configured.
     */
    static readOnly(chainNameOrId: ChainName | number): Database;
    /**
     * Create a Database that is connected to the given Signer.
     * @param signer An ethersjs Signer to use for mutating queries.
     * @returns A Database with a Signer, and a default baseUrl.
     */
    static forSigner(signer: Signer): Promise<Database>;
    /**
     * Create a new prepared statement.
     * Both static and prepared statements are supported. In the current
     * implementation, the prepared statements are prepared locally, and
     * executed remotely (on-chain).
     * @param sql The SQL statement string to prepare.
     * @returns A Statement object constructed with the given SQL string.
     */
    prepare<T = D>(sql: string): Statement<T>;
    /**
     * Execute a set of Statements in batch mode.
     * Batching sends multiple SQL statements inside a single call to the
     * network. This can have a huge performance impact, as it only sends
     * one transaction to the Tableland smart contract, thereby reducing
     * gas costs.
     * Batched statements are similar to SQL transactions. If a statement
     * in the sequence fails, then an error is returned for that specific
     * statement, and it aborts or rolls back the entire sequence.
     * @param statements A set of Statement objects to batch and submit.
     * @param opts Additional options to control execution.
     * @returns An array of run results.
     */
    batch<T = D>(statements: Statement[], opts?: Signal): Promise<Array<Result<T>>>;
    /**
     * Executes one or more queries directly without prepared statements
     * or parameters binding. This method can have poorer performance
     * (prepared statements can be reused in some cases) and, more importantly,
     * is less safe. Only use this method for maintenance and one-shot tasks
     * (example: migration jobs). The input can be one or multiple queries
     * separated by the standard `;`.
     * If an error occurs, an exception is thrown with the query and error
     * messages (see below for `Errors`).
     * Currently, the entire string of statements is submitted as a single
     * transaction. In the future, more "intelligent" transaction planning,
     * splitting, and batching may be used.
     * @param statementStrings A set of SQL statement strings separated by semi-colons.
     * @param opts Additional options to control execution.
     * @returns A single run result.
     */
    exec<T = D>(statementStrings: string, opts?: Signal): Promise<Result<T>>;
    /**
     * Export a (set of) tables to the SQLite binary format.
     * Not implemented yet!
     * @param _opts Additional options to control execution.
     */
    dump(_opts?: Signal): Promise<ArrayBuffer>;
}
//# sourceMappingURL=database.d.ts.map