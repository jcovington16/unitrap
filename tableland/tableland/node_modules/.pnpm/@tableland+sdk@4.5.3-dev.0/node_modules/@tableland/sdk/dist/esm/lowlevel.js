import { extractBaseUrl, extractSigner, normalize, } from "./helpers/index.js";
import { prepareCreateOne, create, } from "./registry/create.js";
import { prepareMutateOne, mutate, } from "./registry/run.js";
import { wrapTransaction, wrapManyTransaction, } from "./registry/utils.js";
import { getQuery, } from "./validator/query.js";
import { ApiError } from "./validator/index.js";
// see `errorWithHint` for usage
const hints = [
    {
        regexp: /syntax error at position \d+ near '.+'/,
        template: function (statement, match) {
            const location = Number(match.input.slice(match.index).split(" ")[4]);
            if (isNaN(location))
                return "";
            const termMatch = match.input.match(/syntax error at position \d+ (near '.+')/);
            if (termMatch == null ||
                termMatch.length < 1 ||
                termMatch[1].indexOf("near '") !== 0) {
                return "";
            }
            // isolate the term from the matched string
            const term = termMatch[1].slice(6, -1);
            const padding = " ".repeat(location - term.length);
            const carrots = "^".repeat(term.length);
            return `${statement}
${padding}${carrots}`;
        },
    },
    {
        regexp: /no such column/,
        template: function (statement, match) {
            // note: the error returned from the validator, and the one generated in the client
            // in the client already include the name of the column.
            return statement;
        },
    },
];
// TODO: this only works if the transaction will only be affecting a single table.
//       I've currently got new versions of this below called execMutateMany and
//       execCreateMany, but we might be able to combine all of these `exec` functions
//       into one when we move to version 5.
export async function exec(config, { type, sql, tables: [first] }) {
    const signer = await extractSigner(config);
    const chainId = await signer.getChainId();
    const baseUrl = await extractBaseUrl(config, chainId);
    const _config = { baseUrl, signer };
    const _params = { chainId, first, statement: sql };
    switch (type) {
        case "create": {
            if (typeof config.aliases?.read === "function") {
                const currentAliases = await config.aliases.read();
                if (currentAliases[first] != null) {
                    throw new Error("table name already exists in aliases");
                }
            }
            const { prefix, ...prepared } = await prepareCreateOne(_params);
            const tx = await create(_config, prepared);
            const wrappedTx = await wrapTransaction(_config, prefix, tx);
            if (typeof config.aliases?.write === "function") {
                const uuTableName = wrappedTx.name;
                const nameMap = {};
                nameMap[first] = uuTableName;
                await config.aliases.write(nameMap);
            }
            return wrappedTx;
        }
        /* c8 ignore next */
        case "acl":
        case "write": {
            if (typeof config.aliases?.read === "function") {
                const nameMap = await config.aliases.read();
                const norm = await normalize(_params.statement, nameMap);
                _params.statement = norm.statements[0];
                _params.first = nameMap[first] != null ? nameMap[first] : first;
            }
            const { prefix, ...prepared } = await prepareMutateOne(_params);
            const tx = await mutate(_config, prepared);
            return await wrapTransaction(_config, prefix, tx);
        }
        /* c8 ignore next 2 */
        default:
            throw new Error("invalid statement type: read");
    }
}
/**
 * This is an internal method that will call the Registry Contract `mutate` method
 * with a set of Runnables.
 * Once the contract call finishes, this returns the mapping of the contract tx results
 * to the Runnables argument.
 */
export async function execMutateMany(config, runnables) {
    const signer = await extractSigner(config);
    const chainId = await signer.getChainId();
    const baseUrl = await extractBaseUrl(config, chainId);
    const _config = { baseUrl, signer };
    const params = { runnables, chainId };
    if (typeof config.aliases?.read === "function") {
        const nameMap = await config.aliases.read();
        params.runnables = await Promise.all(params.runnables.map(async function (runnable) {
            const norm = await normalize(runnable.statement, nameMap);
            runnable.statement = norm.statements[0];
            return runnable;
        }));
    }
    const tx = await mutate(_config, params);
    return await wrapManyTransaction(_config, runnables.map((r) => r.statement), tx);
}
/**
 * This is an internal method that will call the Registry Contract `create` method with
 * a set of sql create statements.
 * Once the contract call finishes, this returns the mapping of the contract tx results to
 * the create statements.
 */
export async function execCreateMany(config, statements) {
    const signer = await extractSigner(config);
    const chainId = await signer.getChainId();
    const baseUrl = await extractBaseUrl(config, chainId);
    const _config = { baseUrl, signer };
    const params = {
        statements: await Promise.all(statements.map(async function (statement) {
            const prepared = await prepareCreateOne({ statement, chainId });
            return prepared.statement;
        })),
        chainId,
    };
    const tx = await create(_config, params);
    const wrappedTx = await wrapManyTransaction(_config, statements, tx);
    if (typeof config.aliases?.write === "function") {
        const currentAliases = await config.aliases.read();
        // Collect the user provided table names to add to the aliases.
        const aliasesTableNames = await Promise.all(statements.map(async function (statement) {
            const norm = await normalize(statement);
            if (currentAliases[norm.tables[0]] != null) {
                throw new Error("table name already exists in aliases");
            }
            return norm.tables[0];
        }));
        const uuTableNames = wrappedTx.names;
        const nameMap = {};
        for (let i = 0; i < aliasesTableNames.length; i++) {
            nameMap[aliasesTableNames[i]] = uuTableNames[i];
        }
        await config.aliases.write(nameMap);
    }
    return wrappedTx;
}
export function errorWithCause(code, cause) {
    return new Error(`${code}: ${cause.message}`, { cause });
}
export function errorWithHint(statement, cause) {
    if (cause.message == null || statement == null)
        return cause;
    let errorMessage = cause.message;
    try {
        for (let i = 0; i < hints.length; i++) {
            const hint = hints[i];
            const match = errorMessage.match(hint.regexp);
            if (match == null)
                continue;
            const hintMessage = hint.template(statement, match);
            errorMessage += hintMessage !== "" ? `\n${hintMessage}` : "";
            break;
        }
        return new Error(errorMessage, { cause });
    }
    catch (err) {
        return cause;
    }
}
function catchNotFound(err) {
    if (err instanceof ApiError && err.status === 404) {
        return [];
    }
    throw err;
}
export async function queryRaw(config, statement, opts = {}) {
    const params = { statement, format: "table" };
    const response = await getQuery(config, params, opts)
        .then((res) => res.rows)
        .catch(catchNotFound);
    return response;
}
export async function queryAll(config, statement, opts = {}) {
    const params = { statement, format: "objects" };
    const response = await getQuery(config, params, opts).catch(catchNotFound);
    return response;
}
export async function queryFirst(config, statement, opts = {}) {
    const response = await queryAll(config, statement, opts).catch(catchNotFound);
    return response.shift() ?? null;
}
export function extractColumn(values, colName) {
    const array = Array.isArray(values) ? values : [values];
    return array.map((row) => {
        if (row[colName] === undefined) {
            throw new Error(`no such column: ${colName.toString()}`);
        }
        return row[colName];
    });
}
//# sourceMappingURL=lowlevel.js.map