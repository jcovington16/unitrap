/// <reference types="node" />
import { EventEmitter } from "events";
import { type TablelandTables } from "@tableland/evm";
import { type TableIdentifier } from "../registry/contract.js";
import { type Config } from "../helpers/index.js";
type ContractMap = Record<number, TablelandTables>;
interface ContractEventListener {
    eventName: string;
    eventListener: (...args: any[]) => void;
}
type ListenerMap = Record<string, {
    chainId: number;
    tableId: string;
    emitter: EventEmitter;
    contractListeners: ContractEventListener[];
}>;
/**
 * TableEventBus provides a way to listen for:
 *  mutations, transfers, and changes to controller
 */
export declare class TableEventBus {
    readonly config: Config;
    readonly contracts: ContractMap;
    readonly listeners: ListenerMap;
    /**
     * Create a TableEventBus instance with the specified connection configuration.
     * @param config The connection configuration. This must include an ethersjs
     * Signer. If passing the config from a pre-existing Database instance, it
     * must have a non-null signer key defined.
     */
    constructor(config?: Partial<Config>);
    /**
     * Start listening to the Registry Contract for events that are associated
     * with a given table.
     * There's only ever one "listener" for a table, but the emitter that
     * Contract listener has can have as many event listeners as the environment
     * supports.
     * @param tableName The full name of table that you want to listen for
     * changes to.
     */
    addListener(tableName: string): Promise<EventEmitter>;
    /**
     * A simple wrapper around `addListener` that returns an async iterable
     * which can be used with the for await ... of pattern.
     * @param tableName The full name of table that you want to listen for
     * changes to.
     */
    addTableIterator<T>(tableName: string): Promise<AsyncIterable<T>>;
    /**
     * Remove a listener (or iterator) based on chain and tableId
     * @param params A TableIdentifier Object. Must have `chainId` and `tableId` keys.
     */
    removeListener(params: TableIdentifier): void;
    removeAllListeners(): void;
    _getContract(chainId: number): Promise<TablelandTables>;
    _ensureListening(listenerId: string, emitter: EventEmitter): Promise<ContractEventListener[]>;
    _attachEmitter(contract: TablelandTables, emitter: EventEmitter, tableIdentifier: TableIdentifier): ContractEventListener[];
}
export {};
//# sourceMappingURL=subscribe.d.ts.map