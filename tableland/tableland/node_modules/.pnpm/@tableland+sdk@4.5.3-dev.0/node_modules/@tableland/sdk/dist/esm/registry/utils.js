import { pollTransactionReceipt, } from "../validator/receipt.js";
import { normalize } from "../helpers/index.js";
import { extractBaseUrl, extractChainId, } from "../helpers/config.js";
import { getContractReceipt, } from "../helpers/ethers.js";
import { validateTables } from "../helpers/parser.js";
function isTransactionReceipt(arg) {
    return (!Array.isArray(arg) &&
        arg.transactionHash != null &&
        arg.tableId != null &&
        arg.chainId != null &&
        arg.blockNumber != null &&
        typeof arg.wait === "function");
}
export function wrapResult(resultsOrReceipt, duration) {
    const meta = { duration };
    const result = {
        meta,
        success: true,
        results: [],
    };
    if (isTransactionReceipt(resultsOrReceipt)) {
        return { ...result, meta: { ...meta, txn: resultsOrReceipt } };
    }
    return { ...result, results: resultsOrReceipt };
}
export async function extractReadonly(conn, { tables, type }) {
    const [{ chainId }] = await validateTables({ tables, type });
    const baseUrl = await extractBaseUrl(conn, chainId);
    return { baseUrl, apiKey: conn.apiKey };
}
/**
 * Given a config, a table name prefix, and a transaction that only affects a single table
 * this will enable waiting for the Validator to materialize the change in the transaction
 * @param {Object} conn - A Database config.
 * @param {string} prefix - A table name prefix.
 * @param {Object} tx - A transaction object that includes a call to the Registry Contract.
 * @returns {WaitableTransactionReceipt}
 */
export async function wrapTransaction(conn, prefix, tx) {
    // TODO: next major we should combine this with wrapManyTransaction
    const _params = await getContractReceipt(tx);
    const chainId = _params.chainId === 0 || _params.chainId == null
        ? await extractChainId(conn)
        : _params.chainId;
    const name = `${prefix}_${chainId}_${_params.tableIds[0]}`;
    const params = { ..._params, chainId, tableId: _params.tableIds[0] };
    const wait = async (opts = {}) => {
        const receipt = await pollTransactionReceipt(conn, params, opts);
        if (receipt.error != null) {
            throw new Error(receipt.error);
        }
        return { ...receipt, name, prefix, prefixes: [prefix], names: [name] };
    };
    return { ...params, wait, name, prefix, prefixes: [prefix], names: [name] };
}
/* A helper function for mapping contract event receipts to table data
 *
 * @param {conn} a database config object
 * @param {statements} either the sql statement strings or the nomralized statement objects that were used in the transaction
 * @param {tx} the transaction object
 * @returns {(WaitableTransactionReceipt & Named)}
 *
 */
export async function wrapManyTransaction(conn, statements, tx) {
    const _params = await getContractReceipt(tx);
    const chainId = _params.chainId === 0 || _params.chainId == null
        ? await extractChainId(conn)
        : _params.chainId;
    // map the transaction events to table names and prefixes then return them to the caller
    const { names, prefixes } = (await Promise.all(_params.tableIds.map(async function (tableId, i) {
        const statementString = isRunnable(statements[i])
            ? statements[i].statement
            : statements[i];
        const normalized = await normalize(statementString);
        if (normalized.type === "create") {
            return {
                name: `${normalized.tables[0]}_${chainId}_${tableId}`,
                prefix: normalized.tables[0],
            };
        }
        return {
            name: normalized.tables[0],
            prefix: normalized.tables[0].split("_").slice(0, -2).join("_"),
        };
    }))).reduce(function (acc, cur) {
        acc.prefixes.push(cur.prefix);
        acc.names.push(cur.name);
        return acc;
    }, { prefixes: [], names: [] });
    const params = { ..._params, chainId };
    // TODO: including `name`, `prefix`, and `tableId` for back compat, will be removed next major
    const tableMeta = {
        names,
        name: names[0],
        tableId: _params.tableIds[0],
        prefixes,
        prefix: prefixes[0],
    };
    const wait = async (opts = {}) => {
        const receipt = await pollTransactionReceipt(conn, params, opts);
        if (receipt.error != null) {
            throw new Error(receipt.error);
        }
        return {
            ...receipt,
            ...tableMeta,
        };
    };
    return {
        ...params,
        wait,
        ...tableMeta,
    };
}
function isRunnable(statement) {
    return statement.tableId !== undefined;
}
//# sourceMappingURL=utils.js.map